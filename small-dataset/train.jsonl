{"source": "private static CookieCollection ParseRequest(string value)\n        {\n            var cookies = new CookieCollection();\n\n            Cookie cookie = null;\n            var ver = 0;\n            var pairs = SplitCookieHeaderValue(value);\n\n            foreach (var t in pairs)\n            {\n                var pair = t.Trim();\n                if (pair.Length == 0)\n                    continue;\n\n                if (pair.StartsWith(\"$version\", StringComparison.OrdinalIgnoreCase))\n                {\n                    ver = int.Parse(GetValue(pair, true));\n                }\n                else if (pair.StartsWith(\"$path\", StringComparison.OrdinalIgnoreCase) && cookie != null)\n                {\n                    cookie.Path = GetValue(pair);\n                }\n                else if (pair.StartsWith(\"$domain\", StringComparison.OrdinalIgnoreCase) && cookie != null)\n                {\n                    cookie.Domain = GetValue(pair);\n                }\n                else if (pair.StartsWith(\"$port\", StringComparison.OrdinalIgnoreCase) && cookie != null)\n                {\n                    cookie.Port = pair.Equals(\"$port\", StringComparison.OrdinalIgnoreCase)\n                        ? \"\\\"\\\"\"\n                        : GetValue(pair);\n                }\n                else\n                {\n                    if (cookie != null)\n                        cookies.Add(cookie);\n\n                    string name;\n                    var val = string.Empty;\n\n                    var pos = pair.IndexOf('=');\n                    if (pos == -1)\n                    {\n                        name = pair;\n                    }\n                    else if (pos == pair.Length - 1)\n                    {\n                        name = pair.Substring(0, pos).TrimEnd(' ');\n                    }\n                    else\n                    {\n                        name = pair.Substring(0, pos).TrimEnd(' ');\n                        val = pair.Substring(pos + 1).TrimStart(' ');\n                    }\n\n                    cookie = new Cookie(name, val);\n                    if (ver != 0)\n                        cookie.Version = ver;\n                }\n            }\n\n            if (cookie != null)\n                cookies.Add(cookie);\n\n            return cookies;\n        }", "mask_locations": [[2046, 2050]], "before": "name", "after": "pair", "repo": "unosquare_embedio"}
{"source": "private static void Accept(Socket socket, SocketAsyncEventArgs e, ref Socket? accepted)\n        {\n            e.AcceptSocket = null;\n            bool asyn;\n\n            try\n            {\n                asyn = socket.AcceptAsync(e);\n            }\n            catch\n            {\n                try\n                {\n                    accepted?.Dispose();\n                }\n                catch\n                {\n                    // ignored\n                }\n\n                accepted = null;\n\n                return;\n            }\n\n            if (!asyn)\n            {\n                ProcessAccept(e);\n            }\n        }", "mask_locations": [[150, 154]], "before": "asyn", "after": "acceptPending", "repo": "unosquare_embedio"}
{"source": "private static void Accept(Socket socket, SocketAsyncEventArgs e, ref Socket? accepted)\n        {\n            e.AcceptSocket = null;\n            bool asyn;\n\n            try\n            {\n                asyn = socket.AcceptAsync(e);\n            }\n            catch\n            {\n                try\n                {\n                    accepted?.Dispose();\n                }\n                catch\n                {\n                    // ignored\n                }\n\n                accepted = null;\n\n                return;\n            }\n\n            if (!asyn)\n            {\n                ProcessAccept(e);\n            }\n        }", "mask_locations": [[556, 560], [203, 207]], "before": "asyn", "after": "acceptPending", "repo": "unosquare_embedio"}
{"source": "public static string EnsureValidLocalPath(string localPath)\n        {\n            if (localPath == null)\n            {\n                throw new InvalidOperationException(\"Local path is null.\");\n            }\n\n            if (localPath.Length == 0)\n            {\n                throw new InvalidOperationException(\"Local path is empty.\");\n            }\n\n            if (string.IsNullOrWhiteSpace(localPath))\n            {\n                throw new InvalidOperationException(\"Local path contains only white space.\");\n            }\n\n            if (localPath.IndexOfAny(_invalidLocalPathChars) >= 0)\n            {\n                throw new InvalidOperationException($\"Local path \\\"{localPath}\\\"contains one or more invalid characters.\");\n            }\n\n            return localPath;\n        }", "mask_locations": [[569, 591]], "before": "_invalidLocalPathChars", "after": "InvalidLocalPathChars", "repo": "unosquare_embedio"}
{"source": "public static async Task<TData> Json<TData>(IHttpContext context)\n        {\n            string body;\n            using (var reader = context.OpenRequestText())\n            {\n                body = await reader.ReadToEndAsync().ConfigureAwait(false);\n            }\n\n            try\n            {\n                return Swan.Formatters.Json.Deserialize<TData>(body);\n            }\n            catch (FormatException)\n            {\n                $\"[{context.Id}] Cannot convert JSON request body to {typeof(TData).Name}, sending 400 Bad Request...\"\n                    .Warn($\"{nameof(RequestDeserializer)}.{nameof(Json)}\");\n\n                throw HttpException.BadRequest(\"Incorrect request data format.\");\n            }\n        }", "mask_locations": [[32, 36]], "before": "Json", "after": "JsonInternal", "repo": "unosquare_embedio"}
{"source": "public async Task HandleRequestAsync(IHttpContext context)\n        {\n            var contextImpl = context as IHttpContextImpl;\n            var mimeTypeProvider = this as IMimeTypeProvider;\n            if (mimeTypeProvider != null)\n                contextImpl?.MimeTypeProviders.Push(mimeTypeProvider);\n\n            try\n            {\n                await OnRequestAsync(context).ConfigureAwait(false);\n                if (IsFinalHandler)\n                    context.SetHandled();\n            }\n            catch (RequestHandlerPassThroughException)\n            { }\n            catch (OperationCanceledException) when (context.CancellationToken.IsCancellationRequested)\n            {\n                throw; // Let the web server handle it\n            }\n            catch (HttpListenerException)\n            {\n                throw; // Let the web server handle it\n            }\n            catch (Exception exception) when (exception is IHttpException)\n            {\n                await HttpExceptionHandler.Handle(LogSource, context, exception, _onHttpException)\n                    .ConfigureAwait(false);\n            }\n            catch (Exception exception)\n            {\n                await ExceptionHandler.Handle(LogSource, context, exception, _onUnhandledException, _onHttpException)\n                    .ConfigureAwait(false);\n            }\n            finally\n            {\n                if (mimeTypeProvider != null)\n                    contextImpl?.MimeTypeProviders.Pop();\n            }\n        }", "mask_locations": [[110, 126]], "before": "IHttpContextImpl", "after": "GetImplementation", "repo": "unosquare_embedio"}
{"source": "private static Task<bool> ValidateHttpOptions(\n            string methods, \n            HttpListenerContext context,\n            IEnumerable<string> validMethods)\n        {\n            var currentMethod = context.RequestHeader(Headers.AccessControlRequestMethod);\n            var currentHeader = context.RequestHeader(Headers.AccessControlRequestHeaders);\n\n            if (!string.IsNullOrWhiteSpace(currentHeader))\n            {\n                // TODO: I need to remove headers out from AllowHeaders\n                context.Response.Headers.Add(Headers.AccessControlAllowHeaders + currentHeader);\n            }\n\n            if (string.IsNullOrWhiteSpace(currentMethod)) \n                return Task.FromResult(true);\n\n            var currentMethods = currentMethod.ToLowerInvariant()\n                .Split(Strings.CommaSplitChar, StringSplitOptions.RemoveEmptyEntries)\n                .Select(x => x.Trim());\n\n            if (methods == Strings.CorsWildcard || currentMethods.All(validMethods.Contains))\n            {\n                context.Response.Headers.Add(Headers.AccessControlAllowMethods + currentMethod);\n\n                return Task.FromResult(true);\n            }\n\n            context.Response.StatusCode = (int) System.Net.HttpStatusCode.BadRequest;\n\n            return Task.FromResult(false);\n        }", "mask_locations": [[535, 542], [1054, 1061]], "before": "Headers", "after": "AddHeader", "repo": "unosquare_embedio"}
{"source": "[Test]\n        public async Task FileContentsMatchInstanceName()\n        {\n            foreach (var item in _instancesNames)\n            {\n                var html = await GetString(item);\n\n                Assert.AreEqual(\n                    TestHelper.GetStaticFolderInstanceIndexFileContents(item),\n                    html, \n                    \"index.html contents match instance name\");\n            }\n        }", "mask_locations": [[108, 123]], "before": "_instancesNames", "after": "InstancesNames", "repo": "unosquare_embedio"}
{"source": "private static byte[] CreateMaskingKey()\n        {\n            var key = new byte[4];\n            WebSocket.RandomNumber.GetBytes(key);\n\n            return key;\n        }", "mask_locations": [[98, 107]], "before": "WebSocket", "after": "WebSocketKey", "repo": "unosquare_embedio"}
{"source": "public static async Task<NameValueCollection> GetRequestFormDataAsync(this IHttpContext @this)\n        {\n            if (!@this.Items.TryGetValue(FormDataKey, out var previousResult))\n            {\n                NameValueCollection result;\n                try\n                {\n                    using var reader = @this.OpenRequestText();\n                    result = UrlEncodedDataParser.Parse(await reader.ReadToEndAsync().ConfigureAwait(false), false);\n                }\n                catch (Exception e)\n                {\n                    @this.Items[FormDataKey] = e;\n                    throw;\n                }\n\n                @this.Items[FormDataKey] = result;\n                return result;\n            }\n\n            switch (previousResult)\n            {\n                case NameValueCollection collection:\n                    return collection;\n\n                case Exception exception:\n                    ExceptionDispatchInfo.Capture(exception).Throw();\n                    throw SelfCheck.Failure(\"Reached unreachable code\");\n\n                case null:\n                    throw SelfCheck.Failure($\"Previous result of {nameof(HttpContextExtensions)}.{nameof(GetRequestFormDataAsync)} is null.\");\n\n                default:\n                    throw SelfCheck.Failure($\"Previous result of {nameof(HttpContextExtensions)}.{nameof(GetRequestFormDataAsync)} is of unexpected type {previousResult.GetType().FullName}\");\n            }\n        }", "mask_locations": [[1007, 1016]], "before": "SelfCheck", "after": "exception", "repo": "unosquare_embedio"}
{"source": "internal void Unmask()\n        {\n            if (Mask == Mask.Off)\n                return;\n\n            Mask = Mask.Off;\n            PayloadData.Mask(MaskingKey);\n            MaskingKey = WebSocket.EmptyBytes;\n        }", "mask_locations": [[188, 197]], "before": "WebSocket", "after": "Array", "repo": "unosquare_embedio"}
{"source": "internal void Unmask()\n        {\n            if (Mask == Mask.Off)\n                return;\n\n            Mask = Mask.Off;\n            PayloadData.Mask(MaskingKey);\n            MaskingKey = WebSocket.EmptyBytes;\n        }", "mask_locations": [[198, 208]], "before": "EmptyBytes", "after": "Empty", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[57, 59]], "before": "ct", "after": "cancellationToken", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[768, 787]], "before": "InternalServerError", "after": "ConfigureAwait", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[276, 288]], "before": "priorMessage", "after": "Response", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[291, 292]], "before": "$", "after": "StandardHtmlResponseAsync", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[753, 767]], "before": "HttpStatusCode", "after": "cancellationToken", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[230, 232]], "before": "ct", "after": "cancellationToken", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[376, 388]], "before": "priorMessage", "after": "sb", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[633, 654]], "before": "Response500HtmlFormat", "after": "Append", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[749, 752]], "before": "Net", "after": "Append", "repo": "unosquare_embedio"}
{"source": "private async Task ResponseServerError(CancellationToken ct, Exception ex, string module)\n        {\n            if (_context.WebServer.UnhandledException != null && await _context.WebServer.UnhandledException.Invoke(_context, ex, ct))\n                return;\n\n            var priorMessage = $\"Failing module name: {module}\";\n            var errorMessage = ex.ExceptionMessage(priorMessage);\n\n            // Log the exception message.\n            ex.Log(nameof(HttpHandler), priorMessage);\n\n            // Send the response over with the corresponding status code.\n            await _context.HtmlResponseAsync(string.Format(Responses.Response500HtmlFormat,\n                    errorMessage,\n                    ex.StackTrace),\n                System.Net.HttpStatusCode.InternalServerError,\n                true,\n                ct);\n        }", "mask_locations": [[446, 448]], "before": "ex", "after": "sb", "repo": "unosquare_embedio"}
{"source": "internal void Close(bool forceClose = false)\n        {\n            if (_sock != null)\n            {\n                GetResponseStream()?.Dispose();\n\n                _oStream = null;\n            }\n\n            if (_sock == null) return;\n\n            forceClose |= !_context.Request.KeepAlive;\n\n            if (!forceClose)\n                forceClose = _context.Response.Headers[\"connection\"] == \"close\";\n\n            if (!forceClose)\n            {\n                if (_context.Request.FlushInput().GetAwaiter().GetResult())\n                {\n                    Reuses++;\n                    Unbind();\n                    Init();\n#pragma warning disable 4014\n                    BeginReadRequest();\n#pragma warning restore 4014\n                    return;\n                }\n            }\n\n            var s = _sock;\n            _sock = null;\n\n            try\n            {\n                s?.Shutdown(SocketShutdown.Both);\n            }\n            catch\n            {\n                // ignored\n            }\n            finally\n            {\n                s?.Dispose();\n            }\n\n            Unbind();\n            RemoveConnection();\n        }", "mask_locations": [[476, 483]], "before": "Request", "after": "HttpListenerRequest", "repo": "unosquare_embedio"}
{"source": "private async Task SetClientStream()\n        {\n#if NET46\n            _tcpClient = new TcpClient(_uri.DnsSafeHost, _uri.Port);\n#else\n            _tcpClient = new TcpClient();\n\n            await _tcpClient.ConnectAsync(_uri.DnsSafeHost, _uri.Port);\n#endif\n            _stream = _tcpClient.GetStream();\n\n#if SSL\n            if (_secure)\n            {\n                var conf = SslConfiguration;\n                var host = conf.TargetHost;\n                if (host != _uri.DnsSafeHost)\n                    throw new WebSocketException(\n                      CloseStatusCode.TlsHandshakeFailure, \"An invalid host name is specified.\");\n\n                try\n                {\n                    var sslStream = new SslStream(\n                      _stream,\n                      false,\n                      conf.ServerCertificateValidationCallback,\n                      conf.ClientCertificateSelectionCallback);\n\n                    sslStream.AuthenticateAsClient(\n                      host,\n                      conf.ClientCertificates,\n                      conf.EnabledSslProtocols,\n                      conf.CheckCertificateRevocation);\n\n                    _stream = sslStream;\n                }\n                catch (Exception ex)\n                {\n                    throw new WebSocketException(CloseStatusCode.TlsHandshakeFailure, ex);\n                }\n            }\n#endif\n        }\n#pragma warning restore CS1998 // Async method lacks 'await' operators and will run synchronously\n", "mask_locations": [[51, 56]], "before": "NET46", "after": "NET452", "repo": "unosquare_embedio"}
{"source": "public static bool TryBanIP(IPAddress address, DateTime banUntil, bool isExplicit = true)\n        {\n            if (Blacklist.ContainsKey(address))\n            {\n                var bannedInfo = Blacklist[address];\n                bannedInfo.BanUntil = banUntil.Ticks;\n                bannedInfo.IsExplicit = isExplicit;\n\n                return true;\n            }\n\n            return Blacklist.TryAdd(address, new BannedInfo()\n            {\n                IPAddress = address,\n                BanUntil = banUntil.Ticks,\n                IsExplicit = isExplicit,\n            });\n        }", "mask_locations": [[242, 250]], "before": "BanUntil", "after": "ExpiresAt", "repo": "unosquare_embedio"}
{"source": "[Test]\n            public async Task RetrieveCookie()\n            {\n                using (var handler = new HttpClientHandler())\n                {\n                    handler.CookieContainer = new CookieContainer();\n                    using (var client = new HttpClient(handler))\n                    {\n                        var request = new HttpRequestMessage(HttpMethod.Get,\n                            WebServerUrl + TestLocalSessionController.GetCookie);\n                        var uri = new Uri(WebServerUrl + TestLocalSessionController.GetCookie);\n\n                        using (var resonse = await client.SendAsync(request))\n                        {\n                            Assert.AreEqual(resonse.StatusCode, HttpStatusCode.OK, \"Status OK\");\n                            var responseCookies = handler.CookieContainer.GetCookies(uri).Cast<Cookie>();\n                            Assert.IsNotNull(responseCookies, \"Cookies are not null\");\n\n                            Assert.Greater(responseCookies.Count(), 0, \"Cookies are not empty\");\n                            var cookieName =\n                                responseCookies.FirstOrDefault(c => c.Name == TestLocalSessionController.CookieName);\n                            Assert.AreEqual(TestLocalSessionController.CookieName, cookieName?.Name);\n                        }\n                    }\n                }\n            }", "mask_locations": [[595, 602]], "before": "resonse", "after": "response", "repo": "unosquare_embedio"}
{"source": "[Test]\n            public async Task RetrieveCookie()\n            {\n                using (var handler = new HttpClientHandler())\n                {\n                    handler.CookieContainer = new CookieContainer();\n                    using (var client = new HttpClient(handler))\n                    {\n                        var request = new HttpRequestMessage(HttpMethod.Get,\n                            WebServerUrl + TestLocalSessionController.GetCookie);\n                        var uri = new Uri(WebServerUrl + TestLocalSessionController.GetCookie);\n\n                        using (var resonse = await client.SendAsync(request))\n                        {\n                            Assert.AreEqual(resonse.StatusCode, HttpStatusCode.OK, \"Status OK\");\n                            var responseCookies = handler.CookieContainer.GetCookies(uri).Cast<Cookie>();\n                            Assert.IsNotNull(responseCookies, \"Cookies are not null\");\n\n                            Assert.Greater(responseCookies.Count(), 0, \"Cookies are not empty\");\n                            var cookieName =\n                                responseCookies.FirstOrDefault(c => c.Name == TestLocalSessionController.CookieName);\n                            Assert.AreEqual(TestLocalSessionController.CookieName, cookieName?.Name);\n                        }\n                    }\n                }\n            }", "mask_locations": [[708, 715]], "before": "resonse", "after": "response", "repo": "unosquare_embedio"}
{"source": "private void ReleaseResources()\n        {\n            if (_client)\n                ReleaseClientResources();\n            else\n                ReleaseServerResources();\n\n            ReleaseCommonResources();\n        }", "mask_locations": [[58, 65]], "before": "_client", "after": "IsClient", "repo": "unosquare_embedio"}
{"source": "get\n            {\n                if (!_codeSet)\n                {\n                    _code = _length > 1\n                            ? BitConverter.ToUInt16(_data.SubArray(0, 2).ToHostOrder(Endianness.Big), 0)\n                            : (ushort)1005;\n\n                    _codeSet = true;\n                }\n\n                return _code;\n            }", "mask_locations": [[39, 47]], "before": "_codeSet", "after": "_code", "repo": "unosquare_embedio"}
{"source": "get\n            {\n                if (!_codeSet)\n                {\n                    _code = _length > 1\n                            ? BitConverter.ToUInt16(_data.SubArray(0, 2).ToHostOrder(Endianness.Big), 0)\n                            : (ushort)1005;\n\n                    _codeSet = true;\n                }\n\n                return _code;\n            }", "mask_locations": [[95, 102]], "before": "_length", "after": "Length", "repo": "unosquare_embedio"}
{"source": "private void FixUpSessionCookie(IHttpContext context)\n        {\n            // get the real \"__session\" cookie value because sometimes there's more than 1 value and System.Net.Cookie only supports 1 value per cookie\n            if (context.Request.Headers[HttpHeaders.Cookie] == null) return;\n\n            var cookieItems = context.Request.Headers[HttpHeaders.Cookie]\n                .Split(Strings.CookieSplitChars, StringSplitOptions.RemoveEmptyEntries);\n\n            foreach (var cookieItem in cookieItems)\n            {\n                var nameValue = cookieItem.Trim().Split(new[] {'='}, StringSplitOptions.RemoveEmptyEntries);\n\n                if (nameValue.Length != 2 || !nameValue[0].Equals(SessionCookieName)) continue;\n\n                var sessionIdValue = nameValue[1].Trim();\n\n                if (!_sessions.ContainsKey(sessionIdValue)) continue;\n\n                context.Request.Cookies[SessionCookieName].Value = sessionIdValue;\n                break;\n            }\n        }", "mask_locations": [[256, 267], [348, 359]], "before": "HttpHeaders", "after": "HttpHeaderNames", "repo": "unosquare_embedio"}
{"source": "[Test]\n            public async Task JsonData_ReturnsOk()\n            {\n                using (var client = new HttpClient())\n                {\n                    List<Person> remoteList;\n                    var request = new HttpRequestMessage(HttpMethod.Get, WebServerUrl + TestController.GetPath);\n\n                    using (var response = await client.SendAsync(request))\n                    {\n                        Assert.AreEqual(response.StatusCode, HttpStatusCode.OK, \"Status Code OK\");\n\n                        var jsonBody = await response.Content.ReadAsStringAsync();\n\n                        Assert.IsNotNull(jsonBody, \"Json Body is not null\");\n                        Assert.IsNotEmpty(jsonBody, \"Json Body is empty\");\n\n                        remoteList = Json.Deserialize<List<Person>>(jsonBody);\n\n                        Assert.IsNotNull(remoteList, \"Json Object is not null\");\n                        Assert.AreEqual(\n                            remoteList.Count,\n                            PeopleRepository.Database.Count,\n                            \"Remote list count equals local list\");\n                    }\n\n                    await ValidatePerson(WebServerUrl + TestController.GetPath + remoteList.First().Key);\n                }\n            }", "mask_locations": [[213, 220]], "before": "request", "after": "jsonBody", "repo": "unosquare_embedio"}
