{"source": "[Theory]\n        [InlineData(DbServer.SqlServer)]\n        [InlineData(DbServer.Sqlite)]\n        private void OwnedTypesTest(DbServer databaseType)\n        {\n            ContextUtil.DbServer = databaseType;\n            using (var context = new TestContext(ContextUtil.GetOptions()))\n            {\n                if (databaseType == DbServer.SqlServer)\n                {\n                    context.Truncate<ChangeLog>();\n                    context.Database.ExecuteSqlRaw(\"TRUNCATE TABLE [\" + nameof(ChangeLog) + \"]\");\n                }\n                else\n                {\n                    //context.ChangeLogs.BatchDelete(); // TODO\n                    context.BulkDelete(context.ChangeLogs.ToList());\n                }\n\n                var entities = new List<ChangeLog>();\n                for (int i = 1; i <= EntitiesNumber; i++)\n                {\n                    entities.Add(new ChangeLog\n                    {\n                        Description = \"Dsc \" + i,\n                        Audit = new Audit\n                        {\n                            ChangedBy = \"User\" + 1,\n                            ChangedTime = DateTime.Now,\n                            InfoType = InfoType.InfoTypeA\n                        }/*,\n                        AuditExtended = new AuditExtended\n                        {\n                            CreatedBy = \"UserS\" + 1,\n                            Remark = \"test\",\n                            CreatedTime = DateTime.Now\n                        },\n                        AuditExtendedSecond = new AuditExtended\n                        {\n                            CreatedBy = \"UserS\" + 1,\n                            Remark = \"sec\",\n                            CreatedTime = DateTime.Now\n                        }*/\n                    });\n                }\n                context.BulkInsert(entities);\n\n                if (databaseType == DbServer.SqlServer)\n                {\n                    context.BulkRead(\n                        entities,\n                        new BulkConfig\n                        {\n                            UpdateByProperties = new List<string> { nameof(Item.Description) }\n                        }\n                    );\n                    Assert.Equal(2, entities[1].ChangeLogId);\n                }\n            }\n        }", "mask_locations": [[133, 145]], "before": "databaseType", "after": "dbServer", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "[Theory]\n        [InlineData(DbServer.SqlServer)]\n        [InlineData(DbServer.Sqlite)]\n        private void OwnedTypesTest(DbServer databaseType)\n        {\n            ContextUtil.DbServer = databaseType;\n            using (var context = new TestContext(ContextUtil.GetOptions()))\n            {\n                if (databaseType == DbServer.SqlServer)\n                {\n                    context.Truncate<ChangeLog>();\n                    context.Database.ExecuteSqlRaw(\"TRUNCATE TABLE [\" + nameof(ChangeLog) + \"]\");\n                }\n                else\n                {\n                    //context.ChangeLogs.BatchDelete(); // TODO\n                    context.BulkDelete(context.ChangeLogs.ToList());\n                }\n\n                var entities = new List<ChangeLog>();\n                for (int i = 1; i <= EntitiesNumber; i++)\n                {\n                    entities.Add(new ChangeLog\n                    {\n                        Description = \"Dsc \" + i,\n                        Audit = new Audit\n                        {\n                            ChangedBy = \"User\" + 1,\n                            ChangedTime = DateTime.Now,\n                            InfoType = InfoType.InfoTypeA\n                        }/*,\n                        AuditExtended = new AuditExtended\n                        {\n                            CreatedBy = \"UserS\" + 1,\n                            Remark = \"test\",\n                            CreatedTime = DateTime.Now\n                        },\n                        AuditExtendedSecond = new AuditExtended\n                        {\n                            CreatedBy = \"UserS\" + 1,\n                            Remark = \"sec\",\n                            CreatedTime = DateTime.Now\n                        }*/\n                    });\n                }\n                context.BulkInsert(entities);\n\n                if (databaseType == DbServer.SqlServer)\n                {\n                    context.BulkRead(\n                        entities,\n                        new BulkConfig\n                        {\n                            UpdateByProperties = new List<string> { nameof(Item.Description) }\n                        }\n                    );\n                    Assert.Equal(2, entities[1].ChangeLogId);\n                }\n            }\n        }", "mask_locations": [[192, 204], [316, 328], [1883, 1895]], "before": "databaseType", "after": "dbServer", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "[Fact]\n        private void GeometryColumnTest()\n        {\n            ContextUtil.DbServer = DbServer.SqlServer;\n            using var context = new TestContext(ContextUtil.GetOptions());\n\n            context.BulkDelete(context.Addresses.ToList());\n\n            var entities = new List<Address> {\n                    new Address {\n                        Street = \"Some Street nn\",\n                        LocationGeography = new Point(52, 13),\n                        LocationGeometry = new Point(52, 13),\n                    }\n                };\n\n            context.BulkInsertOrUpdate(entities);\n        }", "mask_locations": [[103, 112]], "before": "SqlServer", "after": "SQLServer", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "[Fact]\n    private void RunDefaultPKInsertWithGraph()\n    {\n        using var context = new TestContext(ContextUtil.GetOptions());\n        var department = new Department\n        {\n            Name = \"Software\",\n            Divisions = new List<Division>\n                {\n                    new Division{Name = \"Student A\"},\n                    new Division{Name = \"Student B\"},\n                    new Division{Name = \"Student C\"},\n                }\n        };\n\n        context.BulkInsert(new List<Department> { department }, new BulkConfig { IncludeGraph = true });\n    }", "mask_locations": [[1, 5]], "before": "Fact", "after": "Theory", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "private static string GetSqlSetSegment(DbContext context, TableInfo tableInfo, Type updateValuesType, object updateValues, object defaultValues, List<string> updateColumns, List<object> parameters)\n        {\n            string sql = string.Empty;\n            foreach (var propertyNameColumnName in tableInfo.PropertyColumnNamesDict)\n            {\n                string propertyName = propertyNameColumnName.Key;\n                string columnName = propertyNameColumnName.Value;\n                var pArray = propertyName.Split(new char[] { '.' });\n                Type lastType = updateValuesType;\n                PropertyInfo property = lastType.GetProperty(pArray[0]);\n                if (property != null)\n                {\n                    object propertyUpdateValue = property.GetValue(updateValues);\n                    object propertyDefaultValue = property.GetValue(defaultValues);\n                    for (int i = 1; i < pArray.Length; i++)\n                    {\n                        lastType = property.PropertyType;\n                        property = lastType.GetProperty(pArray[i]);\n                        propertyUpdateValue = propertyUpdateValue != null ? property.GetValue(propertyUpdateValue) : propertyUpdateValue;\n                        var lastDefaultValues = lastType.Assembly.CreateInstance(lastType.FullName);\n                        propertyDefaultValue = property.GetValue(lastDefaultValues);\n                    }\n\n                    if (tableInfo.ConvertibleColumnConverterDict.ContainsKey(columnName))\n                    {\n                        propertyUpdateValue = tableInfo.ConvertibleColumnConverterDict[columnName].ConvertToProvider.Invoke(propertyUpdateValue);\n                    }\n\n                    bool isDifferentFromDefault = propertyUpdateValue != null && propertyUpdateValue?.ToString() != propertyDefaultValue?.ToString();\n                    if (isDifferentFromDefault || (updateColumns != null && updateColumns.Contains(propertyName)))\n                    {\n                        sql += $\"[{columnName}] = @{columnName}, \";\n                        propertyUpdateValue = propertyUpdateValue ?? DBNull.Value;\n                        var p = SqlClientHelper.CreateParameter(context.Database.GetDbConnection());\n                        p.ParameterName = $\"@{columnName}\";\n                        p.Value = propertyUpdateValue;\n                        parameters.Add(p);\n                    }\n                }\n            }\n            if (string.IsNullOrEmpty(sql))\n            {\n                throw new InvalidOperationException(\"SET Columns not defined. If one or more columns should be updated to theirs default value use 'updateColumns' argument.\");\n            }\n            sql = sql.Remove(sql.Length - 2, 2); // removes last excess comma and space: \", \"\n            return $\"SET {sql}\";\n        }", "mask_locations": [[2195, 2196]], "before": "p", "after": "param", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "private static string GetSqlSetSegment(DbContext context, TableInfo tableInfo, Type updateValuesType, object updateValues, object defaultValues, List<string> updateColumns, List<object> parameters)\n        {\n            string sql = string.Empty;\n            foreach (var propertyNameColumnName in tableInfo.PropertyColumnNamesDict)\n            {\n                string propertyName = propertyNameColumnName.Key;\n                string columnName = propertyNameColumnName.Value;\n                var pArray = propertyName.Split(new char[] { '.' });\n                Type lastType = updateValuesType;\n                PropertyInfo property = lastType.GetProperty(pArray[0]);\n                if (property != null)\n                {\n                    object propertyUpdateValue = property.GetValue(updateValues);\n                    object propertyDefaultValue = property.GetValue(defaultValues);\n                    for (int i = 1; i < pArray.Length; i++)\n                    {\n                        lastType = property.PropertyType;\n                        property = lastType.GetProperty(pArray[i]);\n                        propertyUpdateValue = propertyUpdateValue != null ? property.GetValue(propertyUpdateValue) : propertyUpdateValue;\n                        var lastDefaultValues = lastType.Assembly.CreateInstance(lastType.FullName);\n                        propertyDefaultValue = property.GetValue(lastDefaultValues);\n                    }\n\n                    if (tableInfo.ConvertibleColumnConverterDict.ContainsKey(columnName))\n                    {\n                        propertyUpdateValue = tableInfo.ConvertibleColumnConverterDict[columnName].ConvertToProvider.Invoke(propertyUpdateValue);\n                    }\n\n                    bool isDifferentFromDefault = propertyUpdateValue != null && propertyUpdateValue?.ToString() != propertyDefaultValue?.ToString();\n                    if (isDifferentFromDefault || (updateColumns != null && updateColumns.Contains(propertyName)))\n                    {\n                        sql += $\"[{columnName}] = @{columnName}, \";\n                        propertyUpdateValue = propertyUpdateValue ?? DBNull.Value;\n                        var p = SqlClientHelper.CreateParameter(context.Database.GetDbConnection());\n                        p.ParameterName = $\"@{columnName}\";\n                        p.Value = propertyUpdateValue;\n                        parameters.Add(p);\n                    }\n                }\n            }\n            if (string.IsNullOrEmpty(sql))\n            {\n                throw new InvalidOperationException(\"SET Columns not defined. If one or more columns should be updated to theirs default value use 'updateColumns' argument.\");\n            }\n            sql = sql.Remove(sql.Length - 2, 2); // removes last excess comma and space: \", \"\n            return $\"SET {sql}\";\n        }", "mask_locations": [[2292, 2293], [2352, 2353], [2422, 2423]], "before": "p", "after": "param", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "private static string GetSqlSetSegment(DbContext context, TableInfo tableInfo, Type updateValuesType, object updateValues, object defaultValues, List<string> updateColumns, List<object> parameters)\n        {\n            string sql = string.Empty;\n            foreach (var propertyNameColumnName in tableInfo.PropertyColumnNamesDict)\n            {\n                string propertyName = propertyNameColumnName.Key;\n                string columnName = propertyNameColumnName.Value;\n                var pArray = propertyName.Split(new char[] { '.' });\n                Type lastType = updateValuesType;\n                PropertyInfo property = lastType.GetProperty(pArray[0]);\n                if (property != null)\n                {\n                    object propertyUpdateValue = property.GetValue(updateValues);\n                    object propertyDefaultValue = property.GetValue(defaultValues);\n                    for (int i = 1; i < pArray.Length; i++)\n                    {\n                        lastType = property.PropertyType;\n                        property = lastType.GetProperty(pArray[i]);\n                        propertyUpdateValue = propertyUpdateValue != null ? property.GetValue(propertyUpdateValue) : propertyUpdateValue;\n                        var lastDefaultValues = lastType.Assembly.CreateInstance(lastType.FullName);\n                        propertyDefaultValue = property.GetValue(lastDefaultValues);\n                    }\n\n                    if (tableInfo.ConvertibleColumnConverterDict.ContainsKey(columnName))\n                    {\n                        propertyUpdateValue = tableInfo.ConvertibleColumnConverterDict[columnName].ConvertToProvider.Invoke(propertyUpdateValue);\n                    }\n\n                    bool isDifferentFromDefault = propertyUpdateValue != null && propertyUpdateValue?.ToString() != propertyDefaultValue?.ToString();\n                    if (isDifferentFromDefault || (updateColumns != null && updateColumns.Contains(propertyName)))\n                    {\n                        sql += $\"[{columnName}] = @{columnName}, \";\n                        propertyUpdateValue = propertyUpdateValue ?? DBNull.Value;\n                        var p = SqlClientHelper.CreateParameter(context.Database.GetDbConnection());\n                        p.ParameterName = $\"@{columnName}\";\n                        p.Value = propertyUpdateValue;\n                        parameters.Add(p);\n                    }\n                }\n            }\n            if (string.IsNullOrEmpty(sql))\n            {\n                throw new InvalidOperationException(\"SET Columns not defined. If one or more columns should be updated to theirs default value use 'updateColumns' argument.\");\n            }\n            sql = sql.Remove(sql.Length - 2, 2); // removes last excess comma and space: \", \"\n            return $\"SET {sql}\";\n        }", "mask_locations": [[2199, 2214]], "before": "SqlClientHelper", "after": "Activator", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "private static string GetSqlSetSegment(DbContext context, TableInfo tableInfo, Type updateValuesType, object updateValues, object defaultValues, List<string> updateColumns, List<object> parameters)\n        {\n            string sql = string.Empty;\n            foreach (var propertyNameColumnName in tableInfo.PropertyColumnNamesDict)\n            {\n                string propertyName = propertyNameColumnName.Key;\n                string columnName = propertyNameColumnName.Value;\n                var pArray = propertyName.Split(new char[] { '.' });\n                Type lastType = updateValuesType;\n                PropertyInfo property = lastType.GetProperty(pArray[0]);\n                if (property != null)\n                {\n                    object propertyUpdateValue = property.GetValue(updateValues);\n                    object propertyDefaultValue = property.GetValue(defaultValues);\n                    for (int i = 1; i < pArray.Length; i++)\n                    {\n                        lastType = property.PropertyType;\n                        property = lastType.GetProperty(pArray[i]);\n                        propertyUpdateValue = propertyUpdateValue != null ? property.GetValue(propertyUpdateValue) : propertyUpdateValue;\n                        var lastDefaultValues = lastType.Assembly.CreateInstance(lastType.FullName);\n                        propertyDefaultValue = property.GetValue(lastDefaultValues);\n                    }\n\n                    if (tableInfo.ConvertibleColumnConverterDict.ContainsKey(columnName))\n                    {\n                        propertyUpdateValue = tableInfo.ConvertibleColumnConverterDict[columnName].ConvertToProvider.Invoke(propertyUpdateValue);\n                    }\n\n                    bool isDifferentFromDefault = propertyUpdateValue != null && propertyUpdateValue?.ToString() != propertyDefaultValue?.ToString();\n                    if (isDifferentFromDefault || (updateColumns != null && updateColumns.Contains(propertyName)))\n                    {\n                        sql += $\"[{columnName}] = @{columnName}, \";\n                        propertyUpdateValue = propertyUpdateValue ?? DBNull.Value;\n                        var p = SqlClientHelper.CreateParameter(context.Database.GetDbConnection());\n                        p.ParameterName = $\"@{columnName}\";\n                        p.Value = propertyUpdateValue;\n                        parameters.Add(p);\n                    }\n                }\n            }\n            if (string.IsNullOrEmpty(sql))\n            {\n                throw new InvalidOperationException(\"SET Columns not defined. If one or more columns should be updated to theirs default value use 'updateColumns' argument.\");\n            }\n            sql = sql.Remove(sql.Length - 2, 2); // removes last excess comma and space: \", \"\n            return $\"SET {sql}\";\n        }", "mask_locations": [[2231, 2238]], "before": "context", "after": "Microsoft", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "private static string GetSqlSetSegment(DbContext context, TableInfo tableInfo, Type updateValuesType, object updateValues, object defaultValues, List<string> updateColumns, List<object> parameters)\n        {\n            string sql = string.Empty;\n            foreach (var propertyNameColumnName in tableInfo.PropertyColumnNamesDict)\n            {\n                string propertyName = propertyNameColumnName.Key;\n                string columnName = propertyNameColumnName.Value;\n                var pArray = propertyName.Split(new char[] { '.' });\n                Type lastType = updateValuesType;\n                PropertyInfo property = lastType.GetProperty(pArray[0]);\n                if (property != null)\n                {\n                    object propertyUpdateValue = property.GetValue(updateValues);\n                    object propertyDefaultValue = property.GetValue(defaultValues);\n                    for (int i = 1; i < pArray.Length; i++)\n                    {\n                        lastType = property.PropertyType;\n                        property = lastType.GetProperty(pArray[i]);\n                        propertyUpdateValue = propertyUpdateValue != null ? property.GetValue(propertyUpdateValue) : propertyUpdateValue;\n                        var lastDefaultValues = lastType.Assembly.CreateInstance(lastType.FullName);\n                        propertyDefaultValue = property.GetValue(lastDefaultValues);\n                    }\n\n                    if (tableInfo.ConvertibleColumnConverterDict.ContainsKey(columnName))\n                    {\n                        propertyUpdateValue = tableInfo.ConvertibleColumnConverterDict[columnName].ConvertToProvider.Invoke(propertyUpdateValue);\n                    }\n\n                    bool isDifferentFromDefault = propertyUpdateValue != null && propertyUpdateValue?.ToString() != propertyDefaultValue?.ToString();\n                    if (isDifferentFromDefault || (updateColumns != null && updateColumns.Contains(propertyName)))\n                    {\n                        sql += $\"[{columnName}] = @{columnName}, \";\n                        propertyUpdateValue = propertyUpdateValue ?? DBNull.Value;\n                        var p = SqlClientHelper.CreateParameter(context.Database.GetDbConnection());\n                        p.ParameterName = $\"@{columnName}\";\n                        p.Value = propertyUpdateValue;\n                        parameters.Add(p);\n                    }\n                }\n            }\n            if (string.IsNullOrEmpty(sql))\n            {\n                throw new InvalidOperationException(\"SET Columns not defined. If one or more columns should be updated to theirs default value use 'updateColumns' argument.\");\n            }\n            sql = sql.Remove(sql.Length - 2, 2); // removes last excess comma and space: \", \"\n            return $\"SET {sql}\";\n        }", "mask_locations": [[2239, 2247]], "before": "Database", "after": "Data", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "internal async Task RunDeleteAllAsync(DbServer databaseType)\n        {\n            using (var context = new TestContext(ContextUtil.GetOptions()))\n            {\n                await context.Items.AddAsync(new Item { }); // used for initial add so that after RESEED it starts from 1, not 0\n                await context.SaveChangesAsync();\n\n                //await context.Items.BatchDeleteAsync(); // TODO: Use after BatchDelete gets implemented for v3.0 \n                await context.BulkDeleteAsync(context.Items.ToList());\n\n                if (databaseType == DbServer.SqlServer)\n                {\n                    await context.Database.ExecuteSqlRawAsync(\"DBCC CHECKIDENT('[dbo].[Item]', RESEED, 0);\").ConfigureAwait(false);\n                }\n                if (databaseType == DbServer.Sqlite)\n                {\n                    await context.Database.ExecuteSqlRawAsync(\"DELETE FROM sqlite_sequence WHERE name = 'Item';\").ConfigureAwait(false);\n                }\n            }\n        }", "mask_locations": [[47, 59]], "before": "databaseType", "after": "dbServer", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "internal async Task RunDeleteAllAsync(DbServer databaseType)\n        {\n            using (var context = new TestContext(ContextUtil.GetOptions()))\n            {\n                await context.Items.AddAsync(new Item { }); // used for initial add so that after RESEED it starts from 1, not 0\n                await context.SaveChangesAsync();\n\n                //await context.Items.BatchDeleteAsync(); // TODO: Use after BatchDelete gets implemented for v3.0 \n                await context.BulkDeleteAsync(context.Items.ToList());\n\n                if (databaseType == DbServer.SqlServer)\n                {\n                    await context.Database.ExecuteSqlRawAsync(\"DBCC CHECKIDENT('[dbo].[Item]', RESEED, 0);\").ConfigureAwait(false);\n                }\n                if (databaseType == DbServer.Sqlite)\n                {\n                    await context.Database.ExecuteSqlRawAsync(\"DELETE FROM sqlite_sequence WHERE name = 'Item';\").ConfigureAwait(false);\n                }\n            }\n        }", "mask_locations": [[549, 561], [773, 785]], "before": "databaseType", "after": "dbServer", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "internal static void LoadSqliteValues<T>(TableInfo tableInfo, T entity, SqliteCommand command, DbContext dbContext)\n        {\n            var propertyColumnsDict = tableInfo.PropertyColumnNamesDict;\n            foreach (var propertyColumn in propertyColumnsDict)\n            {\n                var isShadowProperty = tableInfo.ShadowProperties.Contains(propertyColumn.Key);\n                string parameterName = propertyColumn.Key.Replace(\".\", \"_\");\n                object value;\n                if (!isShadowProperty)\n                {\n                    if (propertyColumn.Key.Contains(\".\")) // ToDo: change IF clause to check for NavigationProperties, optimise, integrate with same code segment from LoadData method\n                    {\n                        var ownedPropertyNameList = propertyColumn.Key.Split('.');\n                        var ownedPropertyName = ownedPropertyNameList[0];\n                        var subPropertyName = ownedPropertyNameList[1];\n                        var ownedFastProperty = tableInfo.FastPropertyDict[ownedPropertyName];\n                        var ownedProperty = ownedFastProperty.Property;\n\n                        var propertyType = Nullable.GetUnderlyingType(ownedProperty.GetType()) ?? ownedProperty.GetType();\n                        if (!command.Parameters.Contains(\"@\" + parameterName))\n                        {\n                            var parameter = new SqliteParameter($\"@{parameterName}\", propertyType);\n                            command.Parameters.Add(parameter);\n                        }\n\n                        if (ownedProperty == null)\n                        {\n                            value = null;\n                        }\n                        else\n                        {\n                            var ownedPropertyValue = entity == null ? null : tableInfo.FastPropertyDict[ownedPropertyName].Get(entity);\n                            var subPropertyFullName = $\"{ownedPropertyName}_{subPropertyName}\";\n                            value = ownedPropertyValue == null ? null : tableInfo.FastPropertyDict[subPropertyFullName]?.Get(ownedPropertyValue);\n                        }\n                    }\n                    else\n                    {\n                        value = tableInfo.FastPropertyDict[propertyColumn.Key].Get(entity);\n                    }\n                }\n                else\n                {\n                    if (tableInfo.BulkConfig.EnableShadowProperties)\n                    {\n                        value = dbContext.Entry(entity).Property(propertyColumn.Key).CurrentValue; // Get the shadow property value\n                    }\n                    else\n                    {\n                        value = entity.GetType().Name; // Set the value for the discriminator column\n                    }\n                }\n\n                if (tableInfo.ConvertibleProperties.ContainsKey(propertyColumn.Key) && value != DBNull.Value)\n                {\n                    value = tableInfo.ConvertibleProperties[propertyColumn.Key].ConvertToProvider.Invoke(value);\n                }\n\n                command.Parameters[$\"@{parameterName}\"].Value = value ?? DBNull.Value;\n            }\n        }", "mask_locations": [[2865, 2886], [3001, 3022]], "before": "ConvertibleProperties", "after": "ConvertibleColumnConverterDict", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[63, 82]], "before": "columnNameValueDict", "after": "createBodyData", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[36, 46]], "before": "Dictionary", "after": "BatchUpdateCreateBodyData", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[4431, 4436]], "before": "value", "after": "compiledExpressionValue", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[177, 181]], "before": "List", "after": "var", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[135, 141]], "before": "dbType", "after": "rootTypeTableInfo", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[1734, 1742]], "before": "parmName", "after": "constantParamName", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[3000, 3010]], "before": "sqlColumns", "after": "CreateUpdateBody", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[4747, 4752]], "before": "value", "after": "compiledExpressionValue", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[2315, 2334], [2614, 2633], [866, 885]], "before": "columnNameValueDict", "after": "createBodyData", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[3016, 3029]], "before": "sqlParameters", "after": "createBodyData", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[4286, 4296]], "before": "tableAlias", "after": "createBodyData", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[4322, 4328]], "before": "dbType", "after": "createBodyData", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[4350, 4363]], "before": "sqlParameters", "after": "$", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[1955, 1963]], "before": "parmName", "after": "constantParamName", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[4265, 4284]], "before": "columnNameValueDict", "after": "Right", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[4334, 4344]], "before": "sqlColumns", "after": "binaryExpression", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[3226, 3232]], "before": "dbType", "after": "DatabaseType", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[922, 928]], "before": "dbType", "after": "assignment", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "public static void CreateUpdateBody(Dictionary<string, string> columnNameValueDict, string tableAlias, Expression expression, DbServer dbType, ref StringBuilder sqlColumns, ref List<object> sqlParameters)\n        {\n            if (expression is MemberInitExpression memberInitExpression)\n            {\n                foreach (var item in memberInitExpression.Bindings)\n                {\n                    if (item is MemberAssignment assignment)\n                    {\n                        if (columnNameValueDict.TryGetValue(assignment.Member.Name, out string value))\n                            sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                        else\n                            sqlColumns.Append($\" [{tableAlias}].[{assignment.Member.Name}]\");\n\n                        sqlColumns.Append(\" =\");\n\n                        CreateUpdateBody(columnNameValueDict, tableAlias, assignment.Expression, dbType, ref sqlColumns, ref sqlParameters);\n\n                        if (memberInitExpression.Bindings.IndexOf(item) < (memberInitExpression.Bindings.Count - 1))\n                            sqlColumns.Append(\" ,\");\n                    }\n                }\n            }\n            else if (expression is MemberExpression memberExpression && memberExpression.Expression is ParameterExpression)\n            {\n                if (columnNameValueDict.TryGetValue(memberExpression.Member.Name, out string value))\n                    sqlColumns.Append($\" [{tableAlias}].[{value}]\");\n                else\n                    sqlColumns.Append($\" [{tableAlias}].[{memberExpression.Member.Name}]\");\n            }\n            else if (expression is ConstantExpression constantExpression)\n            {\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, constantExpression.Value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n            else if (expression is UnaryExpression unaryExpression)\n            {\n                switch (unaryExpression.NodeType)\n                {\n                    case ExpressionType.Convert:\n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    case ExpressionType.Not:\n                        sqlColumns.Append(\" ~\");//this way only for SQL Server \n                        CreateUpdateBody(columnNameValueDict, tableAlias, unaryExpression.Operand, dbType, ref sqlColumns, ref sqlParameters);\n                        break;\n                    default: break;\n                }\n            }\n            else if (expression is BinaryExpression binaryExpression)\n            {\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Left, dbType, ref sqlColumns, ref sqlParameters);\n\n                switch (binaryExpression.NodeType)\n                {\n                    case ExpressionType.Add:\n                        var sqlOperator = SqlAdaptersMapping.GetAdapterDialect(dbType)\n                            .GetBinaryExpressionAddOperation(binaryExpression);\n                        sqlColumns.Append(\" \" + sqlOperator);\n                        break;\n                    case ExpressionType.Divide:\n                        sqlColumns.Append(\" /\");\n                        break;\n                    case ExpressionType.Multiply:\n                        sqlColumns.Append(\" *\");\n                        break;\n                    case ExpressionType.Subtract:\n                        sqlColumns.Append(\" -\");\n                        break;\n                    case ExpressionType.And:\n                        sqlColumns.Append(\" &\");\n                        break;\n                    case ExpressionType.Or:\n                        sqlColumns.Append(\" |\");\n                        break;\n                    case ExpressionType.ExclusiveOr:\n                        sqlColumns.Append(\" ^\");\n                        break;\n                    default: break;\n                }\n\n                CreateUpdateBody(columnNameValueDict, tableAlias, binaryExpression.Right, dbType, ref sqlColumns, ref sqlParameters);\n            }\n            else\n            {\n                var value = Expression.Lambda(expression).Compile().DynamicInvoke();\n                var parmName = $\"param_{sqlParameters.Count}\";\n                // will rely on SqlClientHelper.CorrectParameterType to fix the type before executing\n                sqlParameters.Add(new Microsoft.Data.SqlClient.SqlParameter(parmName, value ?? DBNull.Value));\n                sqlColumns.Append($\" @{parmName}\");\n            }\n        }", "mask_locations": [[934, 944]], "before": "sqlColumns", "after": "createBodyData", "repo": "borisdj_EFCore.BulkExtensions"}
{"source": "private void RunDelete(bool isBulk, DbServer dbServer)\n        {\n            using var context = new TestContext(ContextUtil.GetOptions());\n\n            var entities = AllItemsQuery(context).ToList();\n            // ItemHistories will also be deleted because of Relationship - ItemId (Delete Rule: Cascade)\n            if (isBulk)\n            {\n                var bulkConfig = new BulkConfig() { CalculateStats = true };\n                context.BulkDelete(entities, bulkConfig);\n                if (dbServer == DbServer.SqlServer)\n                {\n                    Assert.Equal(0, bulkConfig.StatsInfo.StatsNumberInserted);\n                    Assert.Equal(0, bulkConfig.StatsInfo.StatsNumberUpdated);\n                    Assert.Equal(entities.Count, bulkConfig.StatsInfo.StatsNumberDeleted);\n                }\n            }\n            else\n            {\n                context.Items.RemoveRange(entities);\n                context.SaveChanges();\n            }\n\n            // TEST\n            int entitiesCount = context.Items.Count();\n            Item lastEntity = context.Items.OrderByDescending(a => a.ItemId).FirstOrDefault();\n\n            Assert.Equal(0, entitiesCount);\n            Assert.Null(lastEntity);\n\n            // RESET AutoIncrement\n            string deleteTableSql = dbServer switch\n            {\n                DbServer.SqlServer => $\"DBCC CHECKIDENT('[dbo].[{nameof(Item)}]', RESEED, 0);\",\n                DbServer.Sqlite => $\"DELETE FROM sqlite_sequence WHERE name = '{nameof(Item)}';\",\n                _ => throw new ArgumentException($\"Unknown database type: '{dbServer}'.\", nameof(dbServer)),\n            };\n            context.Database.ExecuteSqlRaw(deleteTableSql);\n        }", "mask_locations": [[521, 530], [1347, 1356]], "before": "SqlServer", "after": "SQLServer", "repo": "borisdj_EFCore.BulkExtensions"}
